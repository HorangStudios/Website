<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/three@0.119.1/build/three.min.js"></script>
</head>

<body>
    <script>
        // Set up the scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up the player
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0, -5);
        scene.add(player);

        // Set up the controls
        const playerSpeed = 0.1;
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false,
        };

        function handleKeyDown(event) {
            if (event.keyCode === 37) { // Left arrow
                keys.left = true;
            } else if (event.keyCode === 39) { // Right arrow
                keys.right = true;
            } else if (event.keyCode === 38) { // Up arrow
                keys.up = true;
            } else if (event.keyCode === 40) { // Down arrow
                keys.down = true;
            }
        }

        function handleKeyUp(event) {
            if (event.keyCode === 37) { // Left arrow
                keys.left = false;
            } else if (event.keyCode === 39) { // Right arrow
                keys.right = false;
            } else if (event.keyCode === 38) { // Up arrow
                keys.up = false;
            } else if (event.keyCode === 40) { // Down arrow
                keys.down = false;
            }
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Set up the obstacles
        const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
        const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const obstacles = [];
        for (let i = 0; i < 10; i++) {
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -5);
            obstacles.push(obstacle);
            scene.add(obstacle);
        }
        let prevPlayerPosition = new THREE.Vector3();


        function checkCollisions() {
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const distance = player.position.distanceTo(obstacle.position);
                if (distance < 1.5) { // Player and obstacle collide
                    console.log('Collided with obstacle');
                    // Handle collision here (e.g. player takes damage)

                    // Set the player's position to just before the collision occurred
                    player.position.copy(prevPlayerPosition);

                    // Stop the player from moving further in the direction of the obstacle
                    const playerToObstacle = new THREE.Vector3().copy(obstacle.position).sub(player.position).normalize();
                    player.position.add(playerToObstacle.multiplyScalar(1.5 - distance));
                }
            }

            // Update the previous position to the current position
            prevPlayerPosition.copy(player.position);
        }

        function render() {
            requestAnimationFrame(render);

            // Move the player
            const newPlayerPosition = player.position.clone();
            if (keys.left) {
                newPlayerPosition.x -= playerSpeed;
            }
            if (keys.right) {
                newPlayerPosition.x += playerSpeed;
            }
            if (keys.up) {
                newPlayerPosition.y += playerSpeed;
            }
            if (keys.down) {
                newPlayerPosition.y -= playerSpeed;
            }

            // Check for collisions with obstacles
            let collided = false;
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const distance = newPlayerPosition.distanceTo(obstacle.position);
                if (distance < 1.5) { // Player and obstacle collide
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                player.position.copy(newPlayerPosition);
            }

            // Check for collisions with walls or other boundaries here

            renderer.render(scene, camera);
        }

        render();

    </script>
</body>

</html>